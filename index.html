<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- *** FORCE BROWSER TO NOT CACHE THIS FILE *** -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <!-- *** END *** -->
    
    <title>Evacuation Route Finder</title>
    <!-- Load Tailwind CSS from CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for loading spinner */
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        /* Style for the canvas container */
        .canvas-container {
            position: relative;
            width: 100%;
            padding-top: 0; /* removed aspect ratio */
            height: 520px; /* fixed larger height for a bigger map area */
            background-color: #ffffff; /* White background */
            border-radius: 0.5rem;
            overflow: hidden;
            border: 1px solid #e5e7eb;
        }
        #network-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: default;
        }

        /* Styles for the highlighted text path */
        .path-container {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.5rem;
            line-height: 1.75;
        }
        .path-node {
            padding: 0.125rem 0.625rem;
            border-radius: 9999px;
            font-weight: 600;
            color: #1d4ed8; /* text-blue-800 */
            background-color: #dbeafe; /* bg-blue-100 */
            border: 1px solid #bfdbfe; /* border-blue-200 */
            white-space: nowrap;
        }
        .path-node-shelter {
            color: #1d4ed8;
            background-color: #dbeafe;
            border: 1px solid #bfdbfe;
        }
        .path-arrow {
            color: #6b7280;
            font-weight: 600;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-2xl min-h-screen flex flex-col justify-center">

        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold text-blue-800">
                FLOOD EVACUATION AND RELIEF MANAGEMENT SYSTEM FOR CHENNAI

            </h1>
            <p class="text-lg sm:text-xl text-gray-600 mt-2">Chennai Disaster Evacuation Finder</p>
        </header>

        <!-- Network Visualization Card (Always Visible) -->
        <div class="bg-white p-6 sm:p-8 rounded-xl shadow-xl mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Chennai Network Map</h2>
            <div class="canvas-container">
                <canvas id="network-canvas"></canvas>
            </div>
            <p id="map-helper-text" class="text-sm text-blue-600 mt-3 text-center font-medium">
                Hover over the map to see place names
            </p>
        </div>

        <!-- Main Content Card -->
        <main class="bg-white p-6 sm:p-8 rounded-xl shadow-2xl">

            <!-- Error Message Box (Initially Hidden) -->
            <div id="error-box" class="hidden mb-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg">
                <strong class="font-bold">Error!</strong>
                <span class="block sm:inline" id="error-message"></span>
            </div>

            <!-- Input Section -->
            <div id="input-section">
                <div class="space-y-4">
                    
                    <!-- New User Info Inputs -->
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label for="user-name" class="block text-lg font-medium text-gray-700">1. Your Name</label>
                            <input type="text" id="user-name" placeholder="e.g., Kumar" class="mt-1 w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="user-phone" class="block text-lg font-medium text-gray-700">2. Phone Number</label>
                            <input type="tel" id="user-phone" placeholder="10-digit number" class="mt-1 w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                    </div>
                    <!-- End New User Info -->

                    <div>
                        <label for="location-select" class="block text-lg font-medium text-gray-700">
                            3. Select Your Current Location
                        </label>
                        <select id="location-select"
                                class="mt-1 flex-grow w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent bg-white">
                            <option value="" disabled selected>Loading locations...</option>
                        </select>
                    </div>

                    <!-- Inputs for People and Transport -->
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        <div>
                            <label for="people-count" class="block text-lg font-medium text-gray-700">4. How many people?</label>
                            <input type="number" id="people-count" value="1" min="1" class="mt-1 w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <div>
                            <label for="transport-select" class="block text-lg font-medium text-gray-700">5. Need transport?</label>
                            <select id="transport-select" class="mt-1 w-full px-4 py-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                                <option value="no">No, I have my own</option>
                                <option value="yes">Yes, please send help</option>
                            </select>
                        </div>
                    </div>
                    <!-- End Inputs -->
                </div>

                <div class="mt-6">
                    <button id="find-button"
                            class="w-full bg-blue-600 text-white px-6 py-3 font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 ease-in-out flex items-center justify-center">
                        <!-- Loader icon (hidden by default) -->
                        <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-5 w-5 mr-3 hidden"></div>
                        <span>Find Route</span>
                    </button>
                </div>
            </div>

            <!-- Result Section (Initially Hidden) -->
            <div id="result-section" class="mt-8 hidden">
                <h2 class="text-2xl font-semibold text-green-700 mb-4" id="result-header">Route Allocated!</h2>
                
                <!-- New Status Box -->
                <div id="status-box" class="hidden mb-4 p-4 rounded-lg border-2">
                    <p id="status-message" class="font-medium text-lg"></p>
                </div>
                <!-- End Status Box -->

                <!-- Route Details Card -->
                <div class="border rounded-lg overflow-hidden shadow-lg bg-gray-50 p-5">
                    <h3 class="text-xl font-bold text-gray-900" id="shelter-name">
                        <!-- Shelter name will be inserted here -->
                    </h3>
                    <!-- Route Details -->
                    <div class="p-5 bg-gray-50">
                        <h3 class="text-xl font-bold text-gray-900" id="shelter-name">
                            <!-- e.g., Shelter 1 (Guindy) -->
                        </h3>
                        
                        <p class="text-md text-gray-600 mt-3 font-semibold">
                            Path:
                        </p>
                        <!-- *** NEW HIGHLIGHTED PATH CONTAINER *** -->
                        <div id="route-path-container" class="path-container mt-2 mb-4">
                            <!-- Path will be generated here by JS -->
                        </div>
                        
                        <div class="flex flex-wrap gap-4 mt-4 text-center">
                            <div class="flex-1 bg-white p-3 rounded-lg border">
                                <span class="block text-sm text-gray-500">Distance</span>
                                <span class="block text-lg font-semibold text-blue-700" id="route-distance"></span>
                            </div>
                            <div class="flex-1 bg-white p-3 rounded-lg border">
                                <span class="block text-sm text-gray-500">Est. Time</span>
                                <span class="block text-lg font-semibold text-blue-700" id="route-time"></span>
                            </div>
                        </div>
                         <button id="reset-button"
                            class="w-full mt-6 bg-gray-600 text-white px-6 py-3 font-semibold rounded-lg shadow-md hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-offset-2 transition-all duration-200 ease-in-out">
                            Search Again
                        </button>
                    </div>
                </div>
            </div>

        </main>

        <!-- Footer -->
        <footer class="text-center mt-8">
            <p class="text-sm text-gray-500">
                A project based on Operations Research models for disaster management.
            </p>
        </footer>
    </div>

    <script>
        // --- DOM Elements ---
        const findButton = document.getElementById('find-button');
        const resetButton = document.getElementById('reset-button');
        const locationSelect = document.getElementById('location-select');
        const inputSection = document.getElementById('input-section');
        const resultSection = document.getElementById('result-section');
        const loader = document.getElementById('loader');
        const buttonText = findButton.querySelector('span');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');
        
        // --- New Inputs ---
        const userNameInput = document.getElementById('user-name');
        const userPhoneInput = document.getElementById('user-phone');
        const peopleCountInput = document.getElementById('people-count');
        const transportSelect = document.getElementById('transport-select');
        const statusBox = document.getElementById('status-box');
        const statusMessage = document.getElementById('status-message');
        const resultHeader = document.getElementById('result-header');
        
        // --- Canvas Elements ---
        const canvas = document.getElementById('network-canvas');
        const ctx = canvas.getContext('2d');

        // --- Global State ---
        const API_BASE_URL = 'https://or-porject-website.onrender.com/api';
        const AVG_SPEED_KMPH = 15; // Set average speed to 15 km/h
        let networkData = null; // Will hold {nodes, arcs, shelters}
        let scaledNodes = {};   // Will hold {id: {x, y, name, id}}
        let bounds = {};        // Will hold {minLon, maxLon, minLat, maxLat}
        let currentHighlightPath = []; // Store the current path to redraw on resize
        let currentAllocation = null; // Store the last successful allocation
        let scaleFactor = 1.0; // For high-DPI screens

        // Pan and zoom state
        let transform = { x: 0, y: 0, scale: 1 };
    let isDragging = false;
    let lastMousePos = { x: 0, y: 0 };
        let isPanZoomEnabled = false; // keep zoom disabled
    let isPanEnabled = false; // Make map static (no pan)
        let showTooltipsEnabled = true; // tooltips enabled on first page (hover)
        let customFontSize = null; // optionally set for result-page smaller labels
        
        // Hover tooltip state
        let hoveredNode = null;
        let tooltipDiv = null;
        let lastClickTime = 0; // Track click time to differentiate from drag

        // --- Error Handling ---
        function showError(message) {
            errorMessage.textContent = message;
            errorBox.classList.remove('hidden');
        }
        function hideError() {
            errorBox.classList.add('hidden');
        }

        // --- Button State ---
        function setFindButtonLoading(isLoading) {
            if (isLoading) {
                buttonText.textContent = 'Searching...';
                loader.classList.remove('hidden');
                findButton.disabled = true;
                locationSelect.disabled = true;
                peopleCountInput.disabled = true;
                transportSelect.disabled = true;
                userNameInput.disabled = true;
                userPhoneInput.disabled = true;
            } else {
                buttonText.textContent = 'Find Route';
                loader.classList.add('hidden');
                findButton.disabled = false;
                locationSelect.disabled = false;
                peopleCountInput.disabled = false;
                transportSelect.disabled = false;
                userNameInput.disabled = false;
                userPhoneInput.disabled = false;
            }
        }

        // --- Data Loading ---
        async function loadLocations() {
            // Try to populate locations from the backend first; if that fails, fall back to local network data
            locationSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "Select your location";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            locationSelect.appendChild(defaultOption);

            try {
                // Attempt backend call (if available)
                const response = await fetch(`${API_BASE_URL}/get-locations?t=${new Date().getTime()}`);
                if (response.ok) {
                    const locations = await response.json();
                    locations.forEach(location => {
                        const option = document.createElement('option');
                        option.value = location.id;
                        option.textContent = location.name;
                        locationSelect.appendChild(option);
                    });
                    return;
                }
                // If not ok, fall through to local
            } catch (err) {
                // ignore and fallback to local
            }

            // Fallback: use networkData (local chennai_network.json) to populate locations
            if (networkData && networkData.nodes && networkData.nodes.length > 0) {
                // Prefer non-shelter nodes for user locations
                networkData.nodes
                    .filter(n => !n.id.startsWith('s'))
                    .forEach(node => {
                        const option = document.createElement('option');
                        option.value = node.id;
                        option.textContent = node.name;
                        locationSelect.appendChild(option);
                    });
                return;
            }

            // Last-resort error state
            locationSelect.innerHTML = '<option value="" disabled selected>Error loading locations</option>';
        }

        async function loadNetworkData() {
            try {
                // First try backend endpoint (if a backend is provided).
                try {
                    const resp = await fetch(`${API_BASE_URL}/get-network-data?t=${new Date().getTime()}`);
                    if (resp.ok) {
                        networkData = await resp.json();
                    }
                } catch (e) {
                    // ignore and try local file
                }

                // If not loaded from backend, load the local JSON file shipped with the project
                if (!networkData) {
                    const localResp = await fetch('./chennai_network.json');
                    if (!localResp.ok) throw new Error('Local network file not found');
                    networkData = await localResp.json();
                }

                // Set initial full-map bounds and draw
                calculateBounds();
                // Make sure the result-section (which contains the canvas) is visible so canvas gets a size
                // (we intentionally keep the map visible to show the network)
                preprocessCanvasData();
                drawNetwork(); // Draw the initial base map
                // Fit content so nodes are spaced and hover detection becomes accurate
                fitContentToView();
                // Keep the map static on the first page
                isPanEnabled = false;
                isPanZoomEnabled = false;

            } catch (error) {
                console.error('Failed to load network data:', error);
                showError('Could not load network map data.');
            }
        }

        // --- Canvas Drawing Logic ---

        function calculateBounds(nodeIds = []) {
            // Ensure networkData is loaded
            if (!networkData || !networkData.nodes) {
                console.error("Network data not loaded, cannot calculate bounds.");
                return;
            }
            
            let nodesToBound = networkData.nodes;
            
            if (nodeIds.length > 0) {
                const pathNodesSet = new Set(nodeIds);
                nodesToBound = networkData.nodes.filter(n => pathNodesSet.has(n.id));
            }
            
            if (!nodesToBound || nodesToBound.length === 0) {
                nodesToBound = networkData.nodes; // Fallback
            }

            const lons = nodesToBound.map(n => n.lon);
            const lats = nodesToBound.map(n => n.lat);
            bounds = {
                minLon: Math.min(...lons),
                maxLon: Math.max(...lons),
                minLat: Math.min(...lats),
                maxLat: Math.max(...lats),
            };
            
            let lonPad = (bounds.maxLon - bounds.minLon) * 0.1;
            let latPad = (bounds.maxLat - bounds.minLat) * 0.1;

            if (lonPad < 0.01) lonPad = 0.01;
            if (latPad < 0.01) latPad = 0.01;
            
            bounds.minLon -= lonPad;
            bounds.maxLon += lonPad;
            bounds.minLat -= latPad;
            bounds.maxLat += latPad;
        }

        function scaleCoordinates(lon, lat) {
            const { minLon, maxLon, minLat, maxLat } = bounds;
            
            const canvasRect = canvas.getBoundingClientRect();
            // Check for valid canvas dimensions
            if (canvasRect.width === 0 || canvasRect.height === 0) {
                return { x: 0, y: 0 }; // Avoid division by zero
            }
            
            const canvasWidth = canvas.width / scaleFactor;
            const canvasHeight = canvas.height / scaleFactor;
            
            const x = (lon - minLon) / (maxLon - minLon) * canvasWidth;
            const y = (1 - (lat - minLat) / (maxLat - minLat)) * canvasHeight;
            return { x, y };
        }

        function preprocessCanvasData() {
            if (!networkData) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            // If canvas is not yet rendered, skip
            if (canvasRect.width === 0 || canvasRect.height === 0) {
                return;
            }
            
            scaleFactor = window.devicePixelRatio || 1;
            canvas.width = canvasRect.width * scaleFactor;
            canvas.height = canvasRect.height * scaleFactor;
            
            // Apply current transform and scale
            applyTransform(ctx);

            scaledNodes = {};
            networkData.nodes.forEach(node => {
                const { x, y } = scaleCoordinates(node.lon, node.lat);
                scaledNodes[node.id] = {
                    id: node.id,
                    name: node.name,
                    x: x,
                    y: y
                };
            });
        }
        
        function drawNetwork(highlightPathIds = []) {
            if (!ctx || !networkData || !scaledNodes) return;
            
            const canvasWidth = canvas.width / scaleFactor;
            const canvasHeight = canvas.height / scaleFactor;
            
            ctx.save(); // Save the current state
            applyTransform(ctx); // Apply pan/zoom transform
            
            ctx.clearRect(-transform.x, -transform.y, canvasWidth / transform.scale, canvasHeight / transform.scale);

            // If a path is provided, draw the full map (same as first page) and overlay the highlighted route.
            const pathSet = new Set(highlightPathIds || []);
            const pathEdges = new Set();
            for (let i = 0; i < (highlightPathIds || []).length - 1; i++) {
                pathEdges.add(`${highlightPathIds[i]}-${highlightPathIds[i+1]}`);
            }

            // 1. Draw all arcs (faint), but path edges will be drawn on top
            networkData.arcs.forEach(arc => {
                const start = scaledNodes[arc.from];
                const end = scaledNodes[arc.to];
                if (!start || !end) return;

                const isPathEdge = pathEdges.has(`${arc.from}-${arc.to}`) || pathEdges.has(`${arc.to}-${arc.from}`);

                ctx.beginPath();
                ctx.moveTo(start.x, start.y);
                ctx.lineTo(end.x, end.y);
                ctx.strokeStyle = isPathEdge ? '#EF4444' : 'rgba(209,213,219,0.9)';
                ctx.lineWidth = isPathEdge ? 3 : 1;
                ctx.stroke();
            });

            // 2. Draw all nodes (circles only). Collect nodes that need labels and draw labels in screen-space
            const labelNodes = [];
            Object.values(scaledNodes).forEach(node => {
                if (typeof node.x === 'undefined' || typeof node.y === 'undefined') return;

                const isShelter = node.id.startsWith('s');
                const isPathNode = pathSet.has(node.id);

                ctx.beginPath();
                // Determine node size: path nodes are bold (larger), shelters are green, others are gray
                let nodeSize;
                if (isPathNode) {
                    nodeSize = 8 / transform.scale; // Bold/larger for path nodes
                } else if (isShelter) {
                    nodeSize = 4 / transform.scale; // Smaller for shelters
                } else {
                    nodeSize = 3 / transform.scale; // Small for regular nodes
                }
                ctx.arc(node.x, node.y, nodeSize, 0, 2 * Math.PI);

                if (isPathNode) {
                    ctx.fillStyle = '#3B82F6'; // Blue for path nodes
                    ctx.strokeStyle = '#FFFFFF'; // White border
                    ctx.lineWidth = 2 / transform.scale;
                } else if (isShelter) {
                    ctx.fillStyle = '#10B981'; // Green for shelters
                    ctx.strokeStyle = '#059669'; // Darker green stroke
                    ctx.lineWidth = 1.5 / transform.scale;
                } else {
                    ctx.fillStyle = '#9CA3AF'; // Gray for regular nodes
                    ctx.strokeStyle = '#6B7280'; // Darker gray stroke
                    ctx.lineWidth = 1 / transform.scale;
                }

                ctx.fill();
                ctx.stroke();

                // Collect label nodes to render later in screen-space (avoids transform/font scaling issues)
                if (isPathNode || (isShelter && !highlightPathIds.length)) {
                    labelNodes.push({ id: node.id, name: node.name, x: node.x, y: node.y, isPathNode });
                }
            });
            
            ctx.restore(); // Restore the context state (back to identity)

            // Draw labels in screen (CSS pixel) coordinates so text size and offsets are consistent
            if (labelNodes.length > 0) {
                ctx.save();
                // Set transform so 1 unit == 1 CSS pixel (accounting for devicePixelRatio)
                ctx.setTransform(scaleFactor, 0, 0, scaleFactor, 0, 0);

                // Determine base font in CSS pixels
                const baseFontPx = (typeof customFontSize === 'number') ? Math.max(9, customFontSize) : 11;
                ctx.fillStyle = '#1F2937';
                ctx.font = `bold ${baseFontPx}px Inter, sans-serif`;
                ctx.textBaseline = 'middle';

                // Prioritize path nodes so their labels are drawn first
                labelNodes.sort((a, b) => (b.isPathNode === true) - (a.isPathNode === true));

                const drawnRects = [];
                const padding = 4; // px padding around text
                labelNodes.forEach(n => {
                    // Convert node world coords to screen CSS pixels
                    const screenX = n.x * transform.scale + transform.x;
                    const screenY = n.y * transform.scale + transform.y;
                    const text = n.name;
                    const metrics = ctx.measureText(text);
                    // estimate text height from font size
                    const fontMatch = ctx.font.match(/(\d+)px/);
                    const fontPx = fontMatch ? parseInt(fontMatch[1], 10) : baseFontPx;
                    const textWidth = metrics.width;
                    const textHeight = fontPx;

                    const rect = {
                        left: screenX + 10 - padding,
                        top: screenY - textHeight / 2 - padding,
                        right: screenX + 10 + textWidth + padding,
                        bottom: screenY + textHeight / 2 + padding
                    };

                    // Check for overlap with already drawn labels
                    let overlaps = false;
                    for (const r of drawnRects) {
                        if (!(rect.right < r.left || rect.left > r.right || rect.bottom < r.top || rect.top > r.bottom)) {
                            overlaps = true;
                            break;
                        }
                    }

                    // Always draw if it's a path node; otherwise skip if overlaps
                    if (!overlaps || n.isPathNode) {
                        ctx.fillText(text, screenX + 10, screenY + 0);
                        drawnRects.push(rect);
                    }
                });

                ctx.restore();
            }
        }
        
        // Wrapper to draw with a temporary custom font size for result page
        function drawNetworkWithFontSize(pathIds = [], fontSize = null) {
            const prevSize = customFontSize;
            if (typeof fontSize === 'number') customFontSize = fontSize;
            try {
                drawNetwork(pathIds);
            } finally {
                customFontSize = prevSize;
            }
        }
        
        function createHighlightedPath(pathNames, pathIds) {
            const container = document.getElementById('route-path-container');
            container.innerHTML = ''; // Clear old path

            pathNames.forEach((name, index) => {
                const nodeEl = document.createElement('span');
                nodeEl.textContent = name;
                nodeEl.classList.add('path-node');
                
                if (index === pathNames.length - 1 && pathIds[index].startsWith('s')) {
                    nodeEl.classList.add('path-node-shelter');
                }
                container.appendChild(nodeEl);
                
                if (index < pathNames.length - 1) {
                    const arrowEl = document.createElement('span');
                    arrowEl.textContent = '→';
                    arrowEl.classList.add('path-arrow');
                    container.appendChild(arrowEl);
                }
            });
        }


        // --- Pan and Zoom Functions ---
        function applyTransform(ctx) {
            ctx.setTransform(
                scaleFactor * transform.scale, 0, 
                0, scaleFactor * transform.scale, 
                scaleFactor * transform.x, 
                scaleFactor * transform.y
            );
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (evt.clientX - rect.left) / transform.scale - transform.x,
                y: (evt.clientY - rect.top) / transform.scale - transform.y
            };
        }

        // Helper to find node under mouse cursor - check by pixel distance
        function getNodeAtPoint(canvasX, canvasY) {
            const rect = canvas.getBoundingClientRect();
            const mousePixelX = canvasX - rect.left;
            const mousePixelY = canvasY - rect.top;
            
            const hitRadiusPixels = 14; // CSS pixels (slightly larger for reliable hover)

            // Check each node - calculate its screen pixel position in CSS pixels
            for (const nodeId in scaledNodes) {
                const node = scaledNodes[nodeId];

                // node.x/node.y are in canvas CSS coordinates (width/height divided by scaleFactor)
                // Apply world transform (transform.scale and transform.x/y) to get CSS pixel position
                const screenPixelX = node.x * transform.scale + transform.x;
                const screenPixelY = node.y * transform.scale + transform.y;

                // Calculate distance in CSS pixels
                const distX = mousePixelX - screenPixelX;
                const distY = mousePixelY - screenPixelY;
                const dist = Math.sqrt(distX * distX + distY * distY);

                if (dist < hitRadiusPixels) {
                    return node;
                }
            }
            return null;
        }

        // Create tooltip element if not exists
        function createTooltip() {
            if (!tooltipDiv) {
                tooltipDiv = document.createElement('div');
                tooltipDiv.style.position = 'fixed';
                tooltipDiv.style.backgroundColor = '#1F2937';
                tooltipDiv.style.color = '#FFFFFF';
                tooltipDiv.style.padding = '6px 12px';
                tooltipDiv.style.borderRadius = '6px';
                tooltipDiv.style.fontSize = '12px';
                tooltipDiv.style.pointerEvents = 'none';
                tooltipDiv.style.zIndex = '10000';
                tooltipDiv.style.display = 'none';
                tooltipDiv.style.whiteSpace = 'nowrap';
                tooltipDiv.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                document.body.appendChild(tooltipDiv);
            }
            return tooltipDiv;
        }

        function showTooltip(node, x, y) {
            const tooltip = createTooltip();
            tooltip.textContent = node.name;
            tooltip.style.display = 'block';
            
            // Position tooltip with offset
            let tooltipX = x + 10;
            let tooltipY = y + 10;
            
            // Adjust if tooltip goes off the right edge
            if (tooltipX + tooltip.offsetWidth > window.innerWidth) {
                tooltipX = x - tooltip.offsetWidth - 10;
            }
            
            // Adjust if tooltip goes off the bottom edge
            if (tooltipY + tooltip.offsetHeight > window.innerHeight) {
                tooltipY = y - tooltip.offsetHeight - 10;
            }
            
            tooltip.style.left = tooltipX + 'px';
            tooltip.style.top = tooltipY + 'px';
        }

        function hideTooltip() {
            if (tooltipDiv) {
                tooltipDiv.style.display = 'none';
            }
        }

        function updateHelperText() {
            const helperText = document.getElementById('map-helper-text');
            if (showTooltipsEnabled) {
                helperText.textContent = '✓ Hover over any location to see its name';
                helperText.classList.remove('text-blue-600');
                helperText.classList.add('text-green-600');
            } else {
                helperText.textContent = 'Hover over the map to see place names';
                helperText.classList.remove('text-green-600');
                helperText.classList.add('text-blue-600');
            }
        }

        // Fit the content (all nodes) into the canvas view by adjusting transform.scale and transform.x/y
        function fitContentToView(nodeIdsToFit = null, customPadFactor = 0.85) {
            if (!scaledNodes || Object.keys(scaledNodes).length === 0) return;

            const canvasWidth = canvas.width / scaleFactor;
            const canvasHeight = canvas.height / scaleFactor;

            // Determine which nodes to fit
            let nodesToFit = Object.values(scaledNodes);
            if (nodeIdsToFit && nodeIdsToFit.length > 0) {
                const nodeIdSet = new Set(nodeIdsToFit);
                nodesToFit = Object.values(scaledNodes).filter(n => nodeIdSet.has(n.id));
            }

            if (nodesToFit.length === 0) return;

            const xs = nodesToFit.map(n => n.x);
            const ys = nodesToFit.map(n => n.y);
            const contentLeft = Math.min(...xs);
            const contentRight = Math.max(...xs);
            const contentTop = Math.min(...ys);
            const contentBottom = Math.max(...ys);

            const contentWidth = Math.max(1, contentRight - contentLeft);
            const contentHeight = Math.max(1, contentBottom - contentTop);

            // Use custom pad factor if provided
            let desiredScale = Math.min((canvasWidth / contentWidth) * customPadFactor, (canvasHeight / contentHeight) * customPadFactor);
            // Clamp
            desiredScale = Math.max(0.5, Math.min(5, desiredScale));

            transform.scale = desiredScale;

            const contentCenterX = (contentLeft + contentRight) / 2;
            const contentCenterY = (contentTop + contentBottom) / 2;

            // Center content in world (canvas) coordinates
            transform.x = (canvasWidth / 2) - contentCenterX * transform.scale;
            transform.y = (canvasHeight / 2) - contentCenterY * transform.scale;
        }

        // Add mouse event listeners for pan and zoom
        canvas.addEventListener('mousedown', (e) => {
            // No click toggling: map is static and hover shows tooltips on the first page.
            // If panning were enabled, start drag (kept off by default)
            if (isPanEnabled) {
                isDragging = true;
                lastMousePos = {
                    x: e.clientX - transform.x,
                    y: e.clientY - transform.y
                };
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            // Panning only when enabled
            if (isDragging && isPanEnabled) {
                transform.x = e.clientX - lastMousePos.x;
                transform.y = e.clientY - lastMousePos.y;
                drawNetwork(currentHighlightPath);
            } else if (!isPanZoomEnabled && showTooltipsEnabled && resultSection.classList.contains('hidden')) {
                // Show hover tooltip only on the first (input) page when tooltips are enabled
                const node = getNodeAtPoint(e.clientX, e.clientY);
                if (node) {
                    showTooltip(node, e.clientX, e.clientY);
                    hoveredNode = node.id;
                } else {
                    hideTooltip();
                    hoveredNode = null;
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            if (isPanEnabled) canvas.style.cursor = 'default';
        });

        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            if (isPanEnabled) canvas.style.cursor = 'default';
            hideTooltip();
            hoveredNode = null;
        });

        canvas.addEventListener('wheel', (e) => {
            if (!isPanZoomEnabled) return; // Disable zoom on first page
            
            e.preventDefault();
            
            const mousePos = getMousePos(canvas, e);
            const zoom = e.deltaY < 0 ? 1.1 : 0.9;
            
            // Limit zoom level
            const newScale = transform.scale * zoom;
            if (newScale < 0.5 || newScale > 5) return;
            
            transform.scale = newScale;
            
            // Adjust position to zoom toward mouse position
            transform.x -= (mousePos.x * (zoom - 1));
            transform.y -= (mousePos.y * (zoom - 1));
            
            drawNetwork(currentHighlightPath);
        });

        // Set initial cursor style
    canvas.style.cursor = 'default';

        // --- Event Listeners ---
        findButton.addEventListener('click', async () => {
            // --- NEW: Get all inputs ---
            const startNodeId = locationSelect.value;
            const peopleCount = parseInt(peopleCountInput.value, 10);
            const needsTransport = transportSelect.value === 'yes';
            const userName = userNameInput.value;
            const userPhone = userPhoneInput.value;
            
            hideError();

            // --- NEW: Validation ---
            if (!userName) {
                showError('Please enter your name.');
                return;
            }
            if (!userPhone || !/^\d{10}$/.test(userPhone)) {
                showError('Please enter a valid 10-digit phone number.');
                return;
            }
             if (!startNodeId) {
                showError('Please select a location from the dropdown.');
                return;
            }
            if (isNaN(peopleCount) || peopleCount < 1) {
                showError('Please enter a valid number of people (1 or more).');
                return;
            }
            
            setFindButtonLoading(true);

            try {
                // --- Step 1: Call /api/transport-allocate ---
                const allocateResponse = await fetch(`${API_BASE_URL}/transport-allocate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        groups: [{
                            startNodeId: startNodeId,
                            people: peopleCount
                        }],
                        shelterCapacities: null, 
                        allowPartialSplit: false,
                        costMode: "time"
                    }),
                });

                if (!allocateResponse.ok) {
                    const errorData = await allocateResponse.json();
                    throw new Error(errorData.error || 'Network response was not ok');
                }

                const data = await allocateResponse.json();
                
                if (data.unassigned && data.unassigned.length > 0) {
                    throw new Error('All nearby shelters are at full capacity. Please try again later.');
                }
                if (!data.allocations || data.allocations.length === 0) {
                     throw new Error('No allocation could be made. Shelters may be full.');
                }

                // Success! Get the first allocation
                const result = data.allocations[0];
                currentAllocation = result;
                
                // Store the path for proper zooming
                currentHighlightPath = result.path_ids;

                // Show the results - zoom in on highlighted route area
                inputSection.classList.add('hidden');
                resultSection.classList.remove('hidden');
                
                // Calculate full network bounds first
                calculateBounds();
                preprocessCanvasData();
                
                // Now fit the view to only the path nodes (will zoom in on route)
                // Use custom pad factor 0.45 for more zoom-out on result page
                fitContentToView(result.path_ids, 0.45);
                
                // Draw with larger, readable font size for result page
                drawNetworkWithFontSize(result.path_ids, 11);
                
                // Populate results UI
                resultHeader.textContent = `Route Allocated for ${userName}!`;
                document.getElementById('shelter-name').textContent = result.assignedShelterName;
                
                createHighlightedPath(result.path, result.path_ids);
                
                document.getElementById('route-distance').textContent = `${result.distance_km.toFixed(1)} km`;
                
                const timeInMinutes = result.cost_time_min;
                
                if (timeInMinutes < 60) {
                    document.getElementById('route-time').textContent = `${timeInMinutes.toFixed(0)} mins`;
                } else {
                    const hours = Math.floor(timeInMinutes / 60);
                    const minutes = (timeInMinutes % 60).toFixed(0);
                    document.getElementById('route-time').textContent = `${hours}h ${minutes}m`;
                }

                // --- Step 2: Handle transport request ---
                statusBox.classList.remove('hidden', 'bg-green-100', 'border-green-300', 'text-green-800', 'bg-yellow-100', 'border-yellow-300', 'text-yellow-800', 'bg-red-100', 'border-red-300', 'text-red-800');
                if (needsTransport) {
                    await requestTransport(result.assignedShelterId, peopleCount, startNodeId);
                } else {
                    statusMessage.textContent = 'Please proceed to the shelter with your own transport.';
                    statusBox.classList.add('bg-green-100', 'border-green-300', 'text-green-800');
                    setFindButtonLoading(false); // Manually re-enable button
                }

                // Disable tooltips and hide the map helper on results view
                showTooltipsEnabled = false;
                updateHelperText();
                document.getElementById('map-helper-text').style.display = 'none';
                
                // Keep pan/zoom disabled for static output map
                isPanEnabled = false;
                isPanZoomEnabled = false;
                canvas.style.cursor = 'default';

            } catch (error) {
                console.error('Error finding route:', error);
                showError(`${error.message}`);
                setFindButtonLoading(false); // Make sure button is re-enabled on error
            } 
        });
        
        // --- MODIFIED: Transport Request Function ---
        async function requestTransport(shelterId, peopleCount, startNodeId) {
            try {
                const response = await fetch(`${API_BASE_URL}/request-transport`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        shelterId: shelterId,
                        people: peopleCount,
                        startNodeId: startNodeId // Send the user's location
                    }),
                });
                
                if (!response.ok) {
                    throw new Error('Transport request server error.');
                }
                
                const transportData = await response.json();
                
                // --- NEW: Simplified Message ---
                if (transportData.status === 'assigned') {
                    const eta = transportData.message.split("Arrives in approx. ")[1] || "soon";
                    statusMessage.textContent = `Vehicle dispatched! Arrives in approx. ${eta}.`;
                    statusBox.classList.add('bg-green-100', 'border-green-300', 'text-green-800');
                } else if (transportData.status === 'pending') {
                     const eta = transportData.message.split("Total ETA: approx. ")[1] || "soon";
                    statusMessage.textContent = `All vehicles are busy. A new vehicle will be assigned. Total ETA: approx. ${eta}.`;
                    statusBox.classList.add('bg-yellow-100', 'border-yellow-300', 'text-yellow-800');
                } else {
                    // Error status
                    statusMessage.textContent = transportData.message; // Show the server error
                    statusBox.classList.add('bg-red-100', 'border-red-300', 'text-red-800');
                }
                
            } catch (error) {
                console.error("Transport request failed:", error);
                statusMessage.textContent = "Could not contact transport services. Please arrange your own transport.";
                statusBox.classList.add('bg-red-100', 'border-red-300', 'text-red-800');
            } finally {
                 setFindButtonLoading(false); // Re-enable button after all logic is done
            }
        }


        resetButton.addEventListener('click', () => {
            // Hide results, show inputs
            resultSection.classList.add('hidden');
            inputSection.classList.remove('hidden');
            hideError();
            hideTooltip(); // Hide any lingering tooltips
            
            // Disable pan/zoom on first page (keep map static)
            isPanZoomEnabled = false;
            isPanEnabled = false;
            showTooltipsEnabled = true; // Reset tooltip toggle to enable hover on front page
            transform = { x: 0, y: 0, scale: 1 }; // Reset transform
            
            // Reset new inputs
            peopleCountInput.value = '1';
            transportSelect.value = 'no';
            userNameInput.value = '';
            userPhoneInput.value = '';
            statusBox.classList.add('hidden');
            
            locationSelect.value = '';
            locationSelect.disabled = false;
            
            currentHighlightPath = [];
            currentAllocation = null;
            
            // Update helper text back to original and show the helper
            updateHelperText();
            const helper = document.getElementById('map-helper-text');
            helper.style.display = '';
            
            // Reset bounds to full map
            calculateBounds(); 
            preprocessCanvasData(); 
            
            // Reset transform to default
            transform = { x: 0, y: 0, scale: 1 };
            canvas.style.cursor = 'default';
            
            // Redraw the base map
            drawNetwork();
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Load network data first (from local JSON). Then populate locations (fallbacks to network data).
            await loadNetworkData();
            await loadLocations();
            // Ensure helper text matches current tooltip state
            updateHelperText();
        });
        
        // Redraw map on window resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                if (networkData) { // Only run if data is loaded
                    calculateBounds(currentHighlightPath); 
                    preprocessCanvasData(); 
                    // refit content for static map so nodes remain spaced
                    fitContentToView();
                    drawNetwork(currentHighlightPath);
                }
            }, 100); // Debounce resize event
        });

    </script>
</body>

</html>

